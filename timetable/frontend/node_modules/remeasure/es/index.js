var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// external dependencies
import PropTypes from 'prop-types';

// constants
import { ALL_KEYS, OPTIONS_SHAPE } from './constants';

// component
import getMeasuredComponent from './getMeasuredComponent';

// utils
import { createFlattenConvenienceFunction, getMeasuredKeys } from './utils';

/**
 * @module remeasure
 */

/**
 * @function measure
 *
 * @description
 * create higher-order component that injects size and position properties
 * into OriginalComponent as an object under the prop name size and position
 *
 * @param {ReactComponent|Array<string>|Object|string} passedKeys if used without parameters, the component that will be
 * measured, else either single key or array of keys to watch for measurement, or an object of options
 * @param {Object} [passedOptions={}] an object of options to apply for measuring
 * @returns {ReactComponent} the higher-order component that will measure the child and pass down size and
 *
 * position values as props
 */
var measure = function measure(passedKeys) {
  var passedOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof passedKeys === 'function') {
    return getMeasuredComponent(ALL_KEYS, passedOptions)(passedKeys);
  }

  var options = passedKeys && passedKeys.constructor === Object ? _extends({}, passedKeys) : _extends({}, passedOptions);

  PropTypes.checkPropTypes(OPTIONS_SHAPE, options, 'property', 'options');

  return getMeasuredComponent(getMeasuredKeys(passedKeys, options), options);
};

ALL_KEYS.forEach(function (key) {
  measure[key] = createFlattenConvenienceFunction(measure, key);
});

measure.flatten = function (passedKeys) {
  var passedOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var isKeysOptions = passedKeys && passedKeys.constructor === Object;
  var keys = isKeysOptions ? undefined : passedKeys;
  var options = isKeysOptions ? _extends({}, passedKeys) : _extends({}, passedOptions);

  return measure(keys, _extends({}, options, {
    flatten: true
  }));
};

export default measure;