var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// external dependencies
import React, { Component, PureComponent } from 'react';
import { findDOMNode } from 'react-dom';

// constants
import { DEFAULT_OPTIONS } from './constants';

// utils
import { clearValues, getComponentName, getElementValues, getKeysWithSourceAndType, getScopedValues, reduceMeasurementsToMatchingKeys, removeElementResize, setElement, setInheritedMethods, setValuesIfChanged, updateValuesViaRaf } from './utils';

export var createComponentDidMount = function createComponentDidMount(instance, selectedKeys) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$debounce = options.debounce,
      debounceValue = _options$debounce === undefined ? DEFAULT_OPTIONS.debounce : _options$debounce,
      _options$renderOnResi = options.renderOnResize,
      renderOnResize = _options$renderOnResi === undefined ? DEFAULT_OPTIONS.renderOnResize : _options$renderOnResi;

  /**
   * @private
   *
   * @function componentDidMount
   *
   * @description
   * on mount, set the element and its values
   */

  return function () {
    var element = findDOMNode(instance);

    instance._isMounted = true;

    setElement(instance, element, debounceValue, renderOnResize);

    if (element) {
      updateValuesViaRaf(instance);
    }
  };
};

export var createComponentDidUpdate = function createComponentDidUpdate(instance, selectedKeys) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$debounce2 = options.debounce,
      debounceValue = _options$debounce2 === undefined ? DEFAULT_OPTIONS.debounce : _options$debounce2,
      _options$renderOnResi2 = options.renderOnResize,
      renderOnResize = _options$renderOnResi2 === undefined ? DEFAULT_OPTIONS.renderOnResize : _options$renderOnResi2;

  /**
   * @private
   *
   * @function componentDidUpdate
   *
   * @description
   * on update, set the element if it has changed, and update or clear the values based on its existence
   *
   * @returns {void}
   */

  return function () {
    var element = findDOMNode(instance);

    if (element !== instance.element) {
      setElement(instance, element, debounceValue, renderOnResize);
    }

    if (element) {
      return updateValuesViaRaf(instance);
    }

    clearValues(instance, selectedKeys);
  };
};

export var createComponentWillUnmount = function createComponentWillUnmount(instance, selectedKeys) {
  /**
   * @private
   *
   * @function componentWillUnmount
   *
   * @description
   * on unmount, reset all measurements to 0 and remove the resize listener
   */
  return function () {
    instance._isMounted = false;

    instance.setMeasurements(reduceMeasurementsToMatchingKeys(selectedKeys));

    if (instance.element) {
      removeElementResize(instance, instance.element);

      instance.element = null;
    }
  };
};

export var createSetMeasurements = function createSetMeasurements(instance) {
  /**
   * @private
   *
   * @function setMeasurements
   *
   * @description
   * set the measurements synchronously to the instance value and then call forceUpdate if mounted
   *
   * @param {Object} measurements the measurements to assign to the instance
   */
  return function (measurements) {
    instance.measurements = measurements;

    if (instance._isMounted) {
      instance.forceUpdate();
    }
  };
};

export var createSetOriginalRef = function createSetOriginalRef(instance) {
  /**
   * @private
   *
   * @function setOriginalRef
   *
   * @description
   * set the reference to the original component instance to the instance of the HOC
   *
   * @param {HTMLElement|ReactComponent} component the component instance to assign
   */
  return function (component) {
    instance.originalComponent = component;
  };
};

export var createUpdateValuesIfChanged = function createUpdateValuesIfChanged(instance, selectedKeys) {
  /**
   * @private
   *
   * @function updateValuesIfChanged
   *
   * @description
   * get the new values and assign them to state if they have changed
   */
  return function () {
    if (instance.element) {
      setValuesIfChanged(instance, selectedKeys, getElementValues(instance.element, selectedKeys));
    }
  };
};

/**
 * @private
 *
 * @function getMeasuredComponent
 *
 * @description
 * get the decorator to create a higher-order component that will measure the DOM node and pass the requested
 * size / position attributes as props to the PassedComponent
 *
 * @param {Array<string>} keys the keys to get the size / position of
 * @param {Object} options the additional options passed to the decorator
 * @returns {function(ReactComponent): ReactComponent} decorator to create the higher-order component
 */
var getMeasuredComponent = function getMeasuredComponent(keys, options) {
  var selectedKeys = getKeysWithSourceAndType(keys, options);
  var _options$inheritedMet = options.inheritedMethods,
      inheritedMethods = _options$inheritedMet === undefined ? [] : _options$inheritedMet,
      _options$isPure = options.isPure,
      isPure = _options$isPure === undefined ? false : _options$isPure;


  return function (PassedComponent) {
    var passedComponentPrototype = Object.getPrototypeOf(PassedComponent);
    var isPureComponent = passedComponentPrototype === PureComponent;
    var shouldApplyRef = isPureComponent || passedComponentPrototype === Component;

    var ComponentToExtend = isPure || isPureComponent ? PureComponent : Component;
    var displayName = getComponentName(PassedComponent);

    var MeasuredComponent = function (_ComponentToExtend) {
      _inherits(MeasuredComponent, _ComponentToExtend);

      function MeasuredComponent(props) {
        _classCallCheck(this, MeasuredComponent);

        var _this = _possibleConstructorReturn(this, _ComponentToExtend.call(this, props));

        _this.componentDidMount = createComponentDidMount(_this, selectedKeys, options);
        _this.componentDidUpdate = createComponentDidUpdate(_this, selectedKeys, options);
        _this.componentWillUnmount = createComponentWillUnmount(_this, selectedKeys);
        _this.setOriginalRef = createSetOriginalRef(_this);
        _this._isMounted = false;
        _this.element = null;
        _this.originalComponent = null;
        _this.hasResize = null;
        _this.measurements = reduceMeasurementsToMatchingKeys(selectedKeys);
        _this.setMeasurements = createSetMeasurements(_this);
        _this.updateValuesIfChanged = createUpdateValuesIfChanged(_this, selectedKeys);


        if (inheritedMethods.length) {
          setInheritedMethods(_this, inheritedMethods);
        }
        return _this;
      }

      // lifecycle methods


      // instance variables


      // instance methods


      MeasuredComponent.prototype.render = function render() {
        return React.createElement(PassedComponent, _extends({
          ref: shouldApplyRef ? this.setOriginalRef : null
        }, this.props, getScopedValues(this.measurements, selectedKeys, options)));
      };

      return MeasuredComponent;
    }(ComponentToExtend);

    MeasuredComponent.displayName = 'Measured(' + displayName + ')';


    return MeasuredComponent;
  };
};

export default getMeasuredComponent;